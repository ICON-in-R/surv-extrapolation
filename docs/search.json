[
  {
    "objectID": "AIC-BIC-tests.html",
    "href": "AIC-BIC-tests.html",
    "title": "AIC/BIC tests",
    "section": "",
    "text": "Akaike’s Information Criterion (AIC) and the Bayesian Information Criterion (BIC) provide a useful statistical test of the relative fit of alternative parametric models, and they are usually available as outputs from statistical software. Further details on these are available from (Collett 2013). Measures such as the negative 2 log likelihood are only suitable for comparing nested models, whereby one model is nested within another (for example, one model adds an additional covariate compared to another model). Different parametric models which use different probability distributions cannot be nested within one another. Thus the negative 2 log likelihood test is not suitable for assessing the fit of alternative parametric models. The AIC and BIC allow a comparison of models that do not have to be nested, including a term which penalises the use of unnecessary covariates (these are penalised more highly by the BIC). Generally, it is not necessary to include covariates in survival modelling in the context of an RCT as it would be expected that any important covariates would be balanced through the process of randomisation. However, some parametric models have more parameters than others, and the AIC and BIC take account of these – for example an exponential model only has one parameter and so in comparative terms two parameter models such as the Weibull or Gompertz models are penalised. The AIC and BIC statistics therefore weigh up the improved fit of models with the potentially inefficient use of additional parameters, with the use of additional parameters penalised more highly by the BIC relative to the AIC.\nSuppose that we have a statistical model of some data. Let \\(k\\) be the number of estimated parameters in the model. Let \\(\\hat{L}\\) be the maximized value of the likelihood function for the model. Then the AIC value of the model is the following.\n\\[\nAIC = 2k - 2 \\ln({\\hat{L}})\n\\]\nGiven a set of candidate models for the data, the preferred model is the one with the minimum AIC value.\nThe BIC is formally defined as\n\\[\nBIC = k \\ln(n) - 2 \\ln(\\widehat{L})\n\\]\nwhere\n\\(\\hat{L}\\) = the maximized value of the likelihood function of the model \\(M\\), i.e. \\(\\hat{L} = p(x \\mid \\widehat{\\theta}, M)\\), where \\(\\widehat{\\theta}\\) are the parameter values that maximize the likelihood function; \\(x\\) = the observed data; \\(n\\) = the number of data points in \\(x\\), the number of observations, or equivalently, the sample size; \\(k\\) = the number of parameters estimated by the model. For example, in multiple linear regression, the estimated parameters are the intercept, the \\(q\\) slope parameters, and the constant variance of the errors; thus, \\(k = q + 2\\).\n\n\n\n\n\n\nRelative values\n\n\n\nIC values only really make sense when compared between one another i.e relatively. The absolute value is not helpful and depends on the specifics of the model and data."
  },
  {
    "objectID": "AIC-BIC-tests.html#r-example",
    "href": "AIC-BIC-tests.html#r-example",
    "title": "AIC/BIC tests",
    "section": "R example",
    "text": "R example\nCox proportional hazard model\n\nlibrary(survival)\n\ntest1 <- list(time=c(4,3,1,1,2,2,3), \n              status=c(1,1,1,0,1,1,0), \n              x=c(0,2,1,1,1,0,0), \n              sex=c(0,0,0,0,1,1,1)) \n# Fit a stratified model \nfit_ph <- coxph(Surv(time, status) ~ x + strata(sex), test1) \n\nAIC(fit_ph)\n\n[1] 8.655313\n\n##TODO: what this difference with AIC()?\nextractAIC(fit_ph)\n\n[1] 1.000000 8.655313\n\nBIC(fit_ph)\n\n[1] 8.264751\n\n\n\nParametric model with flexsurv\nThe package flexsurv computes the AIC when it fits a model. This can be accessed by `.\\(AIC\\) i.e.\n\nlibrary(flexsurv)\n\nfitg <- flexsurvreg(formula = Surv(futime, fustat) ~ 1, data = ovarian, dist = \"gengamma\")\nfitg$AIC\n\n[1] 199.8981\n\n\nFor other information criteria statistics it is straightforward to calculate these using the flexsurvreg outpuu. For simplicity we can write a function to do them all at the same time, which we shall call fitstats.flexsurvreg.\n\n\nfitstats.flexsurvreg() function\n# helper function\n# from flexsurv github\n# https://github.com/chjackson/flexsurv-dev/issues/44\nfitstats.flexsurvreg <- function(x) {\n  ll <- x$loglik\n  aic <- x$AIC\n  k <- length(x$coefficients)\n  n <- sum(x$data$m[\"(weights)\"])\n  aicc <- aic + ((2 * k) * (k + 1) / (n - k - 1))\n  bic <- - 2 * ll + (k * log(n))\n  \n  data.frame(\n   Df = k,\n    \"n2ll\" = -2 * ll,\n    AIC = aic,\n    AICc = aicc,\n    BIC = bic)\n}\n\n\nNow if we run this we obtain all of the statistics for the previous generalised gamma model fit.\n\nfitstats.flexsurvreg(fitg)\n\n  Df     n2ll      AIC    AICc      BIC\n1  3 193.8981 199.8981 200.989 203.6724\n\n\n\n\nBayesian model with survHE package\nFirst let us fit an example model using survHE.\n\nlibrary(survHE)\n\ndata(bc)\n\nmle <- fit.models(formula = Surv(recyrs,censrec) ~ group,\n                  data = bc,\n                  distr = \"exp\",\n                  method = \"mle\")\n\nNow, the print method for class survHE returns several model fitting summaries.\n\nprint(mle)\n\n\nModel fit for the Exponential model, obtained using Flexsurvreg \n(Maximum Likelihood Estimate). Running time: 0.020 seconds\n\n                 mean         se      L95%      U95%\nrate        0.0603838 0.00845542 0.0458911 0.0794534\ngroupMedium 0.8180219 0.17122084 0.4824352 1.1536086\ngroupPoor   1.5375232 0.16280169 1.2184378 1.8566087\n\nModel fitting summaries\nAkaike Information Criterion (AIC)....: 1668.212\nBayesian Information Criterion (BIC)..: 1681.805\n\n\nIf we wished to access the values directly, perhaps to use in our own code, then we can use\n\nmle$model.fitting\n\n$aic\n[1] 1668.212\n\n$bic\n[1] 1681.805\n\n$dic\nNULL\n\n\nFurther, if we were to fit several different models to compare the IC statistics, which is really the main point of doing it, then survHE also has some nice plotting functions.\n\nmle_multi <- fit.models(formula = Surv(recyrs,censrec) ~ group,\n                  data = bc,\n                  distr = c(\"exp\", \"weibull\", \"gompertz\", \"lognormal\", \"loglogistic\"),\n                  method = \"mle\")\n\nmodel.fit.plot(mle_multi)\n\n\n\nmodel.fit.plot(mle_multi, type = \"BIC\")\n\n\n\nmodel.fit.plot(mle_multi, scale = \"relative\")"
  },
  {
    "objectID": "assess-transformed-km.html",
    "href": "assess-transformed-km.html",
    "title": "Assessing model assumptions using transformed hazard plots",
    "section": "",
    "text": "Prior to fitting a model based on an assumed parametric form for the hazard function, a preliminary study of the validity of this assumption should be carried-out.\nLet us compare the survivor function for the data with that from a chosen model. To do this we will transform the survivor function to produce a plot that should give a straight line if the assumed model is appropriate.\nFor the Weibull, twice taking logs of the survivor function with scale parameter \\(\\lambda\\) and shape parameter \\(\\gamma\\)\n\\[\nlog(-log S(t)) = log \\lambda + \\gamma log t\n\\]\nA plot of \\(log(-log S(t))\\) against \\(log(t)\\) would give an approximately straight line if the Weibull assumption is reasonable. The plot could also be used to give a rough estimate of the parameters.\nSimilarly, for the log-logistic distribution\n\\[\nlog S(t)/(1 - S(t)) = \\theta - \\kappa log t\n\\]\nFor the log-normal distribution\n\\[\n\\Phi^{-1} (1 - S(t)) = (log t - \\mu) / \\sigma\n\\] The slope and intercept of this line provide estimates of \\(\\sigma^{-1}\\) and \\(-\\mu/\\sigma\\), respectively.\nWe can also check the assumption made with using the Cox regression model of proportional hazards by inspecting the log-cumulative hazard plot.\n\\[\nlog H_i(t) = \\beta x_i + log H_0(t)\n\\]\nThe transformed curves for different values of the explanatory variables will be parallel if PH holds.\nSee Collett (2013) for more details."
  },
  {
    "objectID": "assess-transformed-km.html#r-examples",
    "href": "assess-transformed-km.html#r-examples",
    "title": "Assessing model assumptions using transformed hazard plots",
    "section": "R examples",
    "text": "R examples\nThe package commonly used for survival analyses in R is the survival package (Therneau T 2021). We will begin by repeating an example from the survival help documentation.\nThis uses their reliability data. Firstly a little data manipulation is done before we plot the cumulative hazard plot against time using the in-built survival package plotting method with the cumhaz=TRUE argument.\n\nlibrary(survival)\n\ndata(\"reliability\", package = \"survival\")\n\nvdata <- with(valveSeat, data.frame(id = id, time2 = time, status = status))\nfirst <- !duplicated(vdata$id)\nvdata$time1 <- ifelse(first, 0, c(0, vdata$time[-nrow(vdata)]))\ndouble <- which(vdata$time1 == vdata$time2)\nvdata$time1[double] <- vdata$time1[double] - 0.01\nvdata$time2[double - 1] <- vdata$time1[double]\nvdata[1:7, c(\"id\", \"time1\", \"time2\", \"status\")]\n\n   id  time1  time2 status\n1 251   0.00 761.00      0\n2 252   0.00 759.00      0\n3 327   0.00  98.00      1\n4 327  98.00 667.00      0\n5 328   0.00 326.00      1\n6 328 326.00 652.99      1\n7 328 652.99 653.00      1\n\n\n\nfit <- survfit(Surv(time1, time2, status) ~ 1, data = vdata, id = id)\nplot(fit, cumhaz = TRUE, xlab = \"Days\", ylab = \"Cumulative hazard\")\n\n\n\n\nWe can plot the log-cumulative hazard against log-time by simply plotting the survfit output values directly by specifying the x and y data explicitly.\n\nplot(log(fit$time), log(fit$cumhaz), xlab = \"log-Days\", ylab = \"Log-cumulative hazard\", type = \"l\")\n\n\n\n\nFor the following, the latest development version fo the survHE package (Baio 2020) contains all of the functions that we will need. We can obtain this from GitHub with the following.\n\ndevtools::install_github(\"giabaio/survHE\", ref = \"devel\")\n\nIn particular, we will need the plot_transformed_km function.\n\n\nplot_transformed_km() function\nplot_transformed_km <- function(fit, mod = 1, add_legend = FALSE,\n                                graph = \"base\", ...) {\n  \n  dots <- list(...)\n  \n  graph <- match.arg(graph, c(\"base\", \"ggplot2\"))\n  \n  if (length(mod) != 1)\n    stop(\"Please provide at most one model index.\")\n  \n  if (is.numeric(mod) && !mod <= length(fit$models))\n    stop(\"More model names provided than available in list of model fits provided.\")\n  \n  if (is.character(mod) && !mod %in% names(fit$models))\n    stop(\"Model name not available in list of model fits provided.\")\n  \n  dist <- get_distribution(fit, mod)\n  \n  distn_names <- list(\n    \"exp\" = c(\"exp\", \"exponential\"),\n    \"weibull\" = c(\"weibull\", \"weibull.quiet\", \"weibullaf\", \"weibullph\"),\n    \"loglogistic\" = c(\"llogis\", \"loglogistic\"),\n    \"lognormal\" = c(\"lognormal\", \"lnorm\"),\n    \"gompertz\" = \"gompertz\")\n  \n  if (!dist %in% unname(unlist(distn_names)))\n    stop(\"Distribution not available.\")\n  \n  fit_km <- fit$misc$km\n  \n  n_strata <- length(fit_km$strata)\n  \n  if (n_strata == 0 || n_strata == 1) {\n    fit_km$strata <- c(\"group\" = length(fit_km$time))\n  }\n  \n  model_strata <- rep(x = names(fit_km$strata),\n                      times = fit_km$strata)\n  \n  times <- split(fit_km$time, model_strata)\n  survs <- split(fit_km$surv, model_strata)\n  \n  params <- list()\n  \n  if (dist %in% distn_names[[\"exp\"]]) {\n    params <- list(\n      FUN = \"lines\",\n      xlab = \"time\",\n      ylab = \"-log(S(t))\",\n      main = \"Exponential distributional assumption\",\n      x = times,\n      y = lapply(survs, function(x) -log(x)),\n      lty = 1:n_strata,\n      col = 1:n_strata,\n      type = \"l\")\n  }\n  \n  if (dist %in% distn_names[[\"weibull\"]]) {\n    params <- list(\n      FUN = \"lines\",\n      xlab = \"log(time)\",\n      ylab = \"log(-log(S(t))) i.e. log cumulative hazard\",\n      main = \"Weibull distributional assumption\",\n      x = lapply(times, log),\n      y = lapply(survs, function(x) log(-log(x))),\n      lty = 1:n_strata,\n      col = 1:n_strata,\n      type = \"l\")\n  }\n  \n  if (dist %in% distn_names[[\"loglogistic\"]]) {\n    params <- list(\n      FUN = \"lines\",\n      xlab = \"time\",\n      ylab = \"log(S(t)/(1-S(t)))\",\n      main = \"log-Logistic distributional assumption\",\n      x = lapply(times, log),\n      y = lapply(survs, function(x) log(x/(1 - x))),\n      lty = 1:n_strata,\n      col = 1:n_strata,\n      type = \"l\")\n  }\n  \n  if (dist %in% distn_names[[\"lognormal\"]]) {\n    params <- list(\n      FUN = \"lines\",\n      xlab = \"log(time)\",\n      ylab = expression(Phi^-1 ~ (1 - S(t))),\n      main = \"Log-normal distributional assumption\",\n      x = lapply(times, log),\n      y = lapply(survs, function(x) qnorm(1 - x)),\n      lty = 1:n_strata,\n      col = 1:n_strata,\n      type = \"l\")\n  }\n  \n  default_pars <- list(\n    x = NULL,\n    type = \"n\",\n    axes = FALSE,\n    xlab = params$xlab,\n    ylab = params$ylab,\n    main = params$main,\n    xlim = range(pretty(unlist(params$x))),\n    ylim = range(pretty(unlist(params$y))))\n  \n  setup_pars <- modifyList(\n    default_pars, dots[names(default_pars)])\n  \n  if (graph == \"base\") {\n    \n    # empty plot\n    do.call(plot, setup_pars)\n    \n    axis(1); axis(2)\n    \n    # plot lines\n    do.call(mapply, modifyList(params, dots))\n    \n    if (isTRUE(add_legend)) {\n      legend(\"topright\", names(survs), col = params$col,\n             lty = params$lty, bty = \"n\")\n    }\n  }\n  \n  if (graph == \"ggplot2\") {\n    \n    if (!add_legend) {\n      pos.legend <- \"none\"\n    } else {\n      pos.legend <- \"right\"}\n    \n    ggdata <- \n      data.frame(time = unlist(params$x),\n                 y = unlist(params$y)) |>\n      tibble::rownames_to_column(\"Group\") |> \n      mutate(Group = gsub(\"\\\\d+\", \"\", Group))\n    \n    p <- \n      ggplot(ggdata, aes(x = .data$time, y = .data$y,\n                         group = .data$Group, col = .data$Group)) +\n      geom_line() +\n      do.call(labs,\n              list(title = setup_pars$main,\n                   x = setup_pars$xlab,\n                   y = setup_pars$ylab)) +\n      theme_bw() +\n      theme(legend.position = pos.legend)\n    \n    print(p)\n  }\n  \n  invisible(params)\n}\n\nget_distribution <- function(fit, mod) {\n    m <- fit$models[[mod]]\n    tolower(ifelse(fit$method == \"hmc\", m@model_name, m$dlist$name))\n}\n\n\nNow we can repeat the above analysis using the plot_transformed_km function. By setting distr = \"exp\" the cumulative hazard plot is returned.\n\nlibrary(survHE)\n\nfit_exp <- survHE::fit.models(Surv(time1, time2, status) ~ 1,\n                              data = vdata, distr = \"exp\", method = \"mle\")\nplot_transformed_km(fit_exp)\n\n\n\n\nSetting distr = \"weibull\" then we get the log-cumulative hazard against log-time plot.\n\nfit_wei <- survHE::fit.models(Surv(time1, time2, status) ~ 1,\n                              data = vdata, distr = \"weibull\", method = \"mle\")\nplot_transformed_km(fit_wei)\n\n\n\n\nThe plot_transformed_km also provides plots for log-normal and log-logistic distribution assumptions with the corresponding transformation to the survival data.\n\nUsing flexsurv\nFurther, we could use the flexsurv package (Jackson 2016). This package contains lots of functions for a range of survival distributions.\nThe cumulative hazard can be plotted with the flexsurv plotting method with argument type = \"cumhaz\". The Kaplan-Meier is also overlaid by the model fit.\n\nlibrary(\"flexsurv\")\n\nfs1 <- flexsurvreg(Surv(time1, time2, status) ~ 1, data = vdata, dist = \"exp\")\nplot(fs1, type = \"cumhaz\")\n\n\n\nfs2 <- flexsurvreg(Surv(time1, time2, status) ~ 1, data = vdata, dist = \"weibull\")\nplot(fs2, type = \"cumhaz\")\n\n\n\n\n\n\nUsing survHE\n\nlibrary(\"survHE\")\n\nfs1 <- fit.models(Surv(time1, time2, status) ~ 1, data = vdata, dist = \"exp\")\nplot(fs1, type = \"cumhaz\")\n\n\n\nfs2 <- fit.models(Surv(time1, time2, status) ~ 1, data = vdata, dist = \"weibull\")\nplot(fs2, type = \"cumhaz\")"
  },
  {
    "objectID": "blended-curves.html",
    "href": "blended-curves.html",
    "title": "Blended survival curves",
    "section": "",
    "text": "We now present a novel approach to alleviate the problem of survival extrapolation with heavily censored data from clinical trials. The main idea is to mix a flexible model (e.g., Cox semiparametric) to fit as well as possible the observed data and a parametric model encoding assumptions on the expected behaviour of underlying long-term survival. The two are ‘’blended’’ into a single survival curve that is identical with the Cox model over the range of observed times and gradually approaching the parametric model over the extrapolation period based on a weight function. The weight function regulates the way two survival curves are blended, determining how the internal and external sources contribute to the estimated survival over time. Further details can be found in (Che, Green, and Baio 2022).\n\n\n\n\n\n\nShiny app\n\n\n\nThere is an RShiny version of the blendR package for using blended curves interactively in the browser. See here."
  },
  {
    "objectID": "blended-curves.html#r-examples",
    "href": "blended-curves.html#r-examples",
    "title": "Blended survival curves",
    "section": "R Examples",
    "text": "R Examples\nWe need to have the blendR package installed to run this example. This is currently available on GitHub.\n\ndevtools::install_github(\"StatisticsHealthEconomics/blendR\")\n\nIn the first example we will use the survHE and INLA packages to fit the external and observed data models, respectively. If the survHE version for doing HMC is missing then install this.\n\nremotes::install_github('giabaio/survHE', ref='hmc')\n\nAttach these packages.\n\n\n\nWe will use the data set available within blendR and so load data in to the current environment.\n\ndata(\"TA174_FCR\", package = \"blendR\")\nhead(dat_FCR)\n\n# A tibble: 6 × 5\n  patid treat death death_t death_ty\n  <int> <int> <int>   <dbl>    <dbl>\n1     1     1     0  32       2.67  \n2     2     1     0  30.6     2.55  \n3     3     1     0  28       2.33  \n4     8     1     0  30       2.5   \n5    10     1     1   0.458   0.0382\n6    11     1     1   1.57    0.131 \n\n\nFit to the observed data uinsg INLA to obtain the survival object. blendR has a helper function to do this for a piece-wise exponential distribution. The cutpoints argument determines where the points on the survival curve are between which the hazard is constant i.e. an exponential curve.\n\nobs_Surv <- blendR::surv_est_inla(data = dat_FCR,\n                                  cutpoints = seq(0, 180, by = 5))\n\nSimilarly, we fit the external estimate but first we need to create a synthetic data set consistent with expert judgment. This can be elicited ad-hoc or formally and the process of doing so is a field in itself. Once the values have been elicited then blendR had a function to translate from elicited survival curve constraints to a random sample of survival times. In this case we suppose that we have the information that at time 144 the probability of survival is 0.05.\n\ndata_sim <- blendR::ext_surv_sim(t_info = 144,\n                                  S_info = 0.05,\n                                  T_max = 180)\n\next_Surv <- fit.models(formula = Surv(time, event) ~ 1,\n                       data = data_sim,\n                       distr = \"gompertz\",\n                       method = \"hmc\",\n                       priors = list(gom = list(a_alpha = 0.1,\n                                                b_alpha = 0.1)))\n\n\nSAMPLING FOR MODEL 'Gompertz' NOW (CHAIN 1).\nChain 1: \nChain 1: Gradient evaluation took 0 seconds\nChain 1: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\nChain 1: Adjust your expectations accordingly!\nChain 1: \nChain 1: \nChain 1: Iteration:    1 / 2000 [  0%]  (Warmup)\nChain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)\nChain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)\nChain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)\nChain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)\nChain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)\nChain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)\nChain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)\nChain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)\nChain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)\nChain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)\nChain 1: Iteration: 2000 / 2000 [100%]  (Sampling)\nChain 1: \nChain 1:  Elapsed Time: 0.258 seconds (Warm-up)\nChain 1:                0.22 seconds (Sampling)\nChain 1:                0.478 seconds (Total)\nChain 1: \n\nSAMPLING FOR MODEL 'Gompertz' NOW (CHAIN 2).\nChain 2: \nChain 2: Gradient evaluation took 0 seconds\nChain 2: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\nChain 2: Adjust your expectations accordingly!\nChain 2: \nChain 2: \nChain 2: Iteration:    1 / 2000 [  0%]  (Warmup)\nChain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)\nChain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)\nChain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)\nChain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)\nChain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)\nChain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)\nChain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)\nChain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)\nChain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)\nChain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)\nChain 2: Iteration: 2000 / 2000 [100%]  (Sampling)\nChain 2: \nChain 2:  Elapsed Time: 0.233 seconds (Warm-up)\nChain 2:                0.212 seconds (Sampling)\nChain 2:                0.445 seconds (Total)\nChain 2: \n\n\nNow we are nearly ready to fit the blended survival curve. We also need to provide the additional information of how the observed data and external curves are blended together using the beta distribution. That is, we define the blending region min and max and the parameters alpha and beta.\n\nblend_interv <- list(min = 48, max = 150)\nbeta_params <- list(alpha = 3, beta = 3)\n\nbefore putting this all together in the blendsurv function.\n\nble_Surv <- blendR::blendsurv(obs_Surv, ext_Surv, blend_interv, beta_params)\n\nA plotting method is available for blendR objects so simply call the following to return the blended survival curve graph.\n\nplot(ble_Surv)\n\n\n\n\nWe can alternatively use other survival curves and fitting function for each part of the blended curve. Here we use also fit.model from survHE instead of the INLA fitting function for the observed data model.\n\nobs_Surv2 <- fit.models(formula = Surv(death_t, death) ~ 1,\n                        data = dat_FCR,\n                        distr = \"exponential\",\n                        method = \"hmc\")\n\n\nSAMPLING FOR MODEL 'Exponential' NOW (CHAIN 1).\nChain 1: \nChain 1: Gradient evaluation took 0 seconds\nChain 1: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\nChain 1: Adjust your expectations accordingly!\nChain 1: \nChain 1: \nChain 1: Iteration:    1 / 2000 [  0%]  (Warmup)\nChain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)\nChain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)\nChain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)\nChain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)\nChain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)\nChain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)\nChain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)\nChain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)\nChain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)\nChain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)\nChain 1: Iteration: 2000 / 2000 [100%]  (Sampling)\nChain 1: \nChain 1:  Elapsed Time: 0.405 seconds (Warm-up)\nChain 1:                0.278 seconds (Sampling)\nChain 1:                0.683 seconds (Total)\nChain 1: \n\nSAMPLING FOR MODEL 'Exponential' NOW (CHAIN 2).\nChain 2: \nChain 2: Gradient evaluation took 0 seconds\nChain 2: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\nChain 2: Adjust your expectations accordingly!\nChain 2: \nChain 2: \nChain 2: Iteration:    1 / 2000 [  0%]  (Warmup)\nChain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)\nChain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)\nChain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)\nChain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)\nChain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)\nChain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)\nChain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)\nChain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)\nChain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)\nChain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)\nChain 2: Iteration: 2000 / 2000 [100%]  (Sampling)\nChain 2: \nChain 2:  Elapsed Time: 0.462 seconds (Warm-up)\nChain 2:                0.26 seconds (Sampling)\nChain 2:                0.722 seconds (Total)\nChain 2: \n\next_Surv2 <- fit.models(formula = Surv(time, event) ~ 1,\n                        data = data_sim,\n                        distr = \"exponential\",\n                        method = \"hmc\")\n\n\nSAMPLING FOR MODEL 'Exponential' NOW (CHAIN 1).\nChain 1: \nChain 1: Gradient evaluation took 0 seconds\nChain 1: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\nChain 1: Adjust your expectations accordingly!\nChain 1: \nChain 1: \nChain 1: Iteration:    1 / 2000 [  0%]  (Warmup)\nChain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)\nChain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)\nChain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)\nChain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)\nChain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)\nChain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)\nChain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)\nChain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)\nChain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)\nChain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)\nChain 1: Iteration: 2000 / 2000 [100%]  (Sampling)\nChain 1: \nChain 1:  Elapsed Time: 0.183 seconds (Warm-up)\nChain 1:                0.087 seconds (Sampling)\nChain 1:                0.27 seconds (Total)\nChain 1: \n\nSAMPLING FOR MODEL 'Exponential' NOW (CHAIN 2).\nChain 2: \nChain 2: Gradient evaluation took 0 seconds\nChain 2: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.\nChain 2: Adjust your expectations accordingly!\nChain 2: \nChain 2: \nChain 2: Iteration:    1 / 2000 [  0%]  (Warmup)\nChain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)\nChain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)\nChain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)\nChain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)\nChain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)\nChain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)\nChain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)\nChain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)\nChain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)\nChain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)\nChain 2: Iteration: 2000 / 2000 [100%]  (Sampling)\nChain 2: \nChain 2:  Elapsed Time: 0.163 seconds (Warm-up)\nChain 2:                0.09 seconds (Sampling)\nChain 2:                0.253 seconds (Total)\nChain 2: \n\nble_Surv2 <- blendR::blendsurv(obs_Surv2, ext_Surv2, blend_interv, beta_params)\n\nWe can also include the original data Kaplan-Meier in the output plot by simply appending it to the basic plot.\n\n# kaplan-meier\nkm <- survfit(Surv(death_t, death) ~ 1, data = dat_FCR)\n\nplot(ble_Surv2) +\n  geom_line(aes(km$time, km$surv, colour = \"Kaplan-Meier\"),\n            size = 1.25, linetype = \"dashed\")"
  },
  {
    "objectID": "distributions.html",
    "href": "distributions.html",
    "title": "Parametric survival distributions",
    "section": "",
    "text": "There are a wide range of parametric models available, and each have their own characteristics which make them suitable for different data sets. Exponential, Weibull, Gompertz, log-logistic, log normal and Generalised Gamma parametric models should all be considered. These models, and methods to assess which of these models are suitable for particular data sets are described below. Further details on the properties of the individual parametric models that should be considered can be found in (Collett 2013), including diagrams of hazard, survivor and probability density functions which show the variety of shapes that the different models can take, depending upon their parameters. The hazard function is the event rate at time t conditional upon survival until time \\(t\\). The survivor function is the probability that the survival time is greater than or equal to time \\(t\\).\nGeneral equations for survival analysis are the following. The hazard is given by\n\\[\nh(t) = \\frac{f(t)}{S(t)}\n\\]\nThe survival (or survivor) curve is\n\\[\nS(t) = 1 - F(t) = \\int_t^{\\infty} f(t) \\; \\mbox{d}t\n\\]\nand the cumulative hazard is given by\n\\[\nH(t) = \\int h(t) \\; \\mbox{d}t\n\\]\nwhere \\(f(t)\\) is the density function, and \\(F(t)\\) is the cumulative distribution function.\nWe now introduce the separate functions for the most common distributions."
  },
  {
    "objectID": "distributions.html#exponential",
    "href": "distributions.html#exponential",
    "title": "Parametric survival distributions",
    "section": "Exponential",
    "text": "Exponential\nThe hazard is constant i.e.\n\\[\nh(t) = \\lambda\n\\]\nand this then corresponds to\n\\[\nS(t) = \\exp \\left(- \\int \\lambda \\;\\mbox{d}t \\right) = e^{-\\lambda t}\n\\]\nIn R random samples from the exponential distribution can be obtained using rexp e.g. make 10 draws using rexp(n = 10, rate = 2). The other functions are pexp fore the cumulative distribution, qexp is the quantile function and density is dexp.\nWe can easily view a curve as follows.\n\ncurve(dexp(x, rate = 0.5), from=0, to=10, col='blue')\n\n\n\n\nFor the following we will also give an example density plot. Where there is a base R function available to do this we will use this. If not the we will use the equivalent functions from the flexsurv package."
  },
  {
    "objectID": "distributions.html#weibull",
    "href": "distributions.html#weibull",
    "title": "Parametric survival distributions",
    "section": "Weibull",
    "text": "Weibull\nHazard\n\\[\nh(t) = \\lambda \\gamma t^{\\gamma-1}\n\\]\nSurvival function\n\\[\nS(t) = \\exp \\left( - \\int_0^t \\lambda \\gamma u^{\\gamma-1} \\; \\mbox{d}u \\right) = \\exp(- \\lambda t^{\\gamma})\n\\]\n\ncurve(dweibull(x, shape = 2, scale = 4), from=0, to=10, col='blue')"
  },
  {
    "objectID": "distributions.html#gompertz",
    "href": "distributions.html#gompertz",
    "title": "Parametric survival distributions",
    "section": "Gompertz",
    "text": "Gompertz\nHazard function\n\\[\nh(t) = \\lambda e^{\\theta t}\n\\]\nSurvival functions\n\\[\nS(t) = \\exp \\left( \\frac{\\lambda}{\\theta} \\left(1 - e^{\\theta t} \\right) \\right)\n\\]\n\ncurve(flexsurv::dgompertz(x, shape = 0.3, rate = 0.25), from=0, to=10, col='blue')"
  },
  {
    "objectID": "distributions.html#log-logistic",
    "href": "distributions.html#log-logistic",
    "title": "Parametric survival distributions",
    "section": "Log-Logistic",
    "text": "Log-Logistic\nHazard function\n\\[\nh(t) =  \\frac{e^{\\theta} \\kappa t^{\\kappa - 1}}{1 + e^{\\theta} t^{\\kappa}}\n\\]\nSurvival function\n\\[\nS(t) = \\left( 1 + e^{\\theta} t^{\\kappa} \\right)^{-1}\n\\]\n\ncurve(flexsurv::dllogis(x, shape = 3, log = TRUE), from=0, to=10, col='blue')"
  },
  {
    "objectID": "distributions.html#log-normal",
    "href": "distributions.html#log-normal",
    "title": "Parametric survival distributions",
    "section": "Log normal",
    "text": "Log normal\nSurvival function\n\\[\nS(t) = 1 - \\Phi\\left( \\frac{\\log t - \\mu}{\\sigma} \\right)\n\\]\n\ncurve(dlnorm(x, meanlog = 2, sdlog = 0.5), from=0, to=10, col='blue')"
  },
  {
    "objectID": "distributions.html#generalised-gamma",
    "href": "distributions.html#generalised-gamma",
    "title": "Parametric survival distributions",
    "section": "Generalised Gamma",
    "text": "Generalised Gamma\nSurvival function\n\\[\nS(t) = 1 - \\Gamma_{\\lambda t}^{\\theta} (\\rho)\n\\]\nwhere \\(\\Gamma_{\\lambda t} (\\rho)\\) is the incomplete gamma function.\n\ncurve(flexsurv::dgengamma(x, mu = 5, sigma = 2, Q = 0.1), from=0, to=10, col='blue')"
  },
  {
    "objectID": "Introduction.html",
    "href": "Introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "In health economic evaluations, the choice of intervention typically has consequences for lifetime survival. Therefore we often want to estimate the expected survival over a lifetime horizon,\n\\[\n\\mbox{E}[T \\mid \\boldsymbol{\\theta}]= \\int_0^\\infty S(t)dt.\n\\]\nThis implies that the expected (i.e. mean) survival time can be computed as the “area under the survival curve”. More importantly, this clarifies why applications of survival modelling in HTA requires a full extrapolation of the survival curve: the focus of the economic analysis is on the mean survival time and in order to obtain it, we need to be able to derive the full survival curve in the range of times \\(t = 0, \\ldots, \\infty\\).\nA challenge with estimating lifetime survival based on trial data is that we can only observe death times \\(T\\) that are shorter than the follow-up time of the trial. For people still alive at the end of the trial, the survival times are right-censored. To estimate \\(E(T)\\), we need to know the distribution of \\(T\\) over all plausible values of \\(T\\)."
  },
  {
    "objectID": "Introduction.html#r-packages",
    "href": "Introduction.html#r-packages",
    "title": "Introduction",
    "section": "R packages",
    "text": "R packages\nThere are many R package available for doing survival analysis, both on CRAN and on other site such as GitHub. Those we will make most use of for the exercises will be\n\nsurvHE: Survival analysis in health economic evaluation contains a suite of functions to systematise the workflow involving survival analysis in health economic evaluation. survHE can fit a large range of survival models using both a frequentist approach (by calling the R package flexsurv) and a Bayesian perspective.\nflexsurv: Flexible parametric models for time-to-event data, including the Royston-Parmar spline model, generalized gamma and generalized F distributions. Any user-defined parametric distribution can be fitted, given at least an R function defining the probability density or hazard. There are also tools for fitting and predicting from fully parametric multi-state models, based on either cause-specific hazards or mixture models.\nINLA: R-INLA is a more general package in R that do approximate Bayesian inference for Latent Gaussian Models.\nsurvival: Contains the core survival analysis routines, including definition of Surv objects, Kaplan-Meier and Aalen-Johansen (multi-state) curves, Cox models, and parametric accelerated failure time models."
  },
  {
    "objectID": "medians.html",
    "href": "medians.html",
    "title": "Median survival time",
    "section": "",
    "text": "The median survival time is the length of time from either the date of diagnosis or the start of treatment for a disease, such as cancer, that half of the patients in a group of patients diagnosed with the disease are still alive. In a clinical trial, measuring the median overall survival is one way to see how well a new treatment works. Also called median survival.\n\n\n\n\n\n\nTip\n\n\n\nThe median is useful but it is the expected or mean survival time that is of particular interest for HTA."
  },
  {
    "objectID": "medians.html#r-examples",
    "href": "medians.html#r-examples",
    "title": "Median survival time",
    "section": "R Examples",
    "text": "R Examples\nIn this example we will see a comparison of survival probabilities at given landmark times as well as the comparison of observed (i.e. based on Kaplan-Meier) and predicted medians (using the respective formula to calculate the median for each distribution) based on fitted models for each of the 6 main distributions we consider.\nThe summary method for a survHE object from the survHE package returns mean survival times, including the median mean survival time (not be be confused with the mean median survival time!). For an exponential model fit with no covariates,\n\nlibrary(survHE)\n\ndata(bc)\n\nmle <- fit.models(formula = Surv(recyrs, censrec) ~ 1,\n                  data = bc,\n                  distr = \"exp\",\n                  method = \"mle\")\n\nsummary(mle)\n\n\nEstimated average survival time distribution* \n mean sd 2.5% median 97.5%\n    0  0    0      0     0\n\n*Computed over the range: [0.02192-7.28493] using 1000 simulations.\nNB: Check that the survival curves tend to 0 over this range!\n\n\nNote that this is calculated over a closed range and not the entire time line.\nWe can compare these parametric estimate with the median survival time from the Kaplan-Meier. This is available from the survHE output in misc$km and the equation\n\\[\n\\min \\{t : \\hat{S}(t) < 0.5 \\}\n\\]\n\nt_med <- min(mle$misc$km$time[mle$misc$km$surv < 0.5])\nt_low <- min(mle$misc$km$time[mle$misc$km$lower < 0.5])\nt_upp <- min(mle$misc$km$time[mle$misc$km$upper < 0.5])\n\nt_med\n\n[1] 4.950685\n\n\nThere is clearly some repitition here so we can simplify as follows.\n\nsurv_median <- function(S, sname) {\n  min(S[[\"time\"]][S[[sname]] < 0.5])\n}\n\nKM <- mle$misc$km\n\nsurv_median(KM, \"surv\")\n\n[1] 4.950685\n\nsurv_median(KM, \"lower\")\n\n[1] 4.347945\n\nsurv_median(KM, \"upper\")\n\n[1] 5.561644\n\n\nPlotting the Kaplan-Meier we can indicate these median times.\n\nsurvfit(Surv(recyrs, censrec) ~ 1, data = bc) |> \n  plot()\nabline(h = 0.5)\nabline(v = c(t_low, t_med, t_upp), lty = c(2,1,2))\n\n\n\n\n\nDirect estimates\nIf we denote the median with \\(t_{50}\\) then to calculate the medians ourselves we can take the fitted coefficient value from the fit.model output and use an inverese of the survival function. In the case of the exponential distribution this is\n\\[\nt_{50} = -\\log (0.5)/\\lambda\n\\]\n\nrate <- mle$models$Exponential$coefficients\nexp(rate)\n\n[1] 0.1414765\n\n# closed form\nmeantime <- -log(0.5)/exp(rate)\nmeantime\n\n[1] 4.899379\n\n\nThe log-logistic distribution has CDF\n\\[\n\\frac{1}{(1 + (t/\\alpha)^{\\beta})^2}\n\\]\nWhich leads to the median \\(t_{50} = \\alpha\\), i.e. simply the shape parameter.\nSimilarly, the Gompertz distribution median is\n\\[\n(1/b) \\log[(-1/\\eta) \\log(0.5) + 1]\n\\]\nThe Weibull distribution median is\n\\[\n\\lambda [- \\log(0.5)]^{1/k}\n\\]\nThe log-normal distribution median is\n\\[\n\\exp(\\mu)\n\\]\nThe gamma distribution has no simple closed form formula for the median.\n\n\nSimulation-based estimates\nNote that the parameter returned from fit.model is the log of the rate. More generally, we can simulate (multiple) survival curves from the coefficient posterior and estimate the median for each of these. So, sample from the posterior using make.surv() from the survHE package to obtain output for the single curve case as follows.\n\nsurv_exp <- make.surv(mle)\n\nThe sampled survival curves from make.surv() have slightly different names so let us redefine the median function and then extract the median times.\n\nsurv_median <- function(S, sname) {\n  min(S[[\"t\"]][S[[sname]] < 0.5])\n}\n\nsurv <- surv_exp$S[[1]]\n\nsurv_median(surv, \"S\")\n\nWarning in min(S[[\"t\"]][S[[sname]] < 0.5]): no non-missing arguments to min;\nreturning Inf\n\n\n[1] Inf\n\n\nIt follows that we can do something similar for multiple simulations to obtain uncertainty bounds. Repeating the above but for 100 simulations,\n\nsim100 <- make.surv(mle, nsim = 100)\n\ndirect estimates are\n\nrtimes <- -log(0.5)/unlist(sim100$sim)\nrtimes\n\n  [1] 5.129274 4.994966 5.143881 5.354052 4.122856 4.678172 4.636991 5.118422\n  [9] 4.797051 5.042906 4.734239 4.604857 5.175513 5.230992 4.882798 4.672267\n [17] 4.774438 4.569511 4.470436 4.557443 5.063112 4.608875 4.964719 5.499736\n [25] 4.715466 5.229862 4.999613 4.890220 4.914381 4.906810 5.050804 4.804258\n [33] 4.907729 5.002857 5.212119 5.219587 4.481277 4.574514 5.074015 4.966932\n [41] 4.668094 4.948967 5.061563 4.784166 5.048711 4.458354 5.227693 5.429019\n [49] 5.120158 4.989762 4.932618 5.333248 4.696408 4.967057 4.466571 5.487606\n [57] 4.998161 5.591646 5.264726 4.879369 4.805861 4.880135 5.017423 5.313824\n [65] 5.083576 5.123904 5.346759 4.884546 5.449213 4.774073 5.015380 5.133944\n [73] 4.407795 4.844915 4.878669 5.220372 4.979860 4.726083 4.809170 5.019526\n [81] 4.644216 4.937766 5.326748 4.888761 4.809222 4.958810 4.589322 4.520686\n [89] 4.866668 4.998618 5.270166 4.956875 5.127313 4.557834 4.634553 5.416319\n [97] 4.637491 4.237438 5.067876 5.459735\n\n\nand simulated estimates\n\nsurv <- sim100$S[[1]]\n\nt_S <- surv_median(surv, \"S\")\nt_low <- surv_median(surv, \"low\")\nt_upp <- surv_median(surv, \"upp\")\n\nt_S\n\n[1] Inf\n\n\nThe plot with all samples of medians is,\n\nplot(mle) + \n  geom_vline(xintercept = rtimes, alpha = 0.1, col = \"darkgrey\", size = 2) +\n  geom_vline(xintercept = meantime) +\n  geom_vline(xintercept = t_low, linetype = 2) +\n  geom_vline(xintercept = t_upp, linetype = 2)\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\nMultiple distributions\nIn the same way as for a single distribution, we can extend the analysis for multiple distributions at the same time. We show this for exponential and log-logistic distributions. First, fit the models and show the survival curves.\n\nfit2 <- fit.models(formula = Surv(recyrs, censrec) ~ 1,\n                   data = bc,\n                   dist = c(\"exp\", \"loglogistic\"),\n                   method = \"mle\")\n\nplot(fit2)\n\n\n\n\nThen, sample the survival curves and rearrange so that its straightforward to use the data in the same way as above.\n\nNSIM <- 100\nsim <- list()\nsim[[1]] <- make.surv(fit2, mod = 1, nsim = NSIM)\nsim[[2]] <- make.surv(fit2, mod = 2, nsim = NSIM)\n\nsim <- purrr::transpose(sim)\n\nWe can then get the direct estimates,\n\nrtimes <- list()\nrtimes[[1]] <- -log(0.5)/sim$sim[[1]][[1]][, \"rate\"]\nrtimes[[2]] <- sim$sim[[2]][[1]][, \"scale\"]\n\nrtimes\n\n[[1]]\n  [1] 4.891236 5.558763 4.640760 4.955321 5.064032 4.952246 4.417258 4.785022\n  [9] 4.386729 5.174528 5.029145 5.103521 5.152045 4.913786 4.775232 4.745259\n [17] 4.921242 4.645849 4.648273 4.611302 4.596660 4.749946 5.000975 4.492578\n [25] 5.041510 5.037908 4.682468 4.941710 4.295228 5.419128 5.059493 5.461694\n [33] 5.067809 5.056597 4.723538 4.858205 5.189288 4.734738 4.644047 4.843307\n [41] 4.829866 4.534743 4.992454 4.865820 4.911094 4.890826 4.477248 4.928613\n [49] 4.710085 4.725032 5.070692 5.015997 4.919846 5.099190 4.665799 4.651995\n [57] 5.059758 4.107772 4.951071 5.553459 4.228464 4.758949 4.842218 4.608252\n [65] 5.199355 4.760746 5.160960 4.295892 4.690292 5.199554 4.795301 5.300827\n [73] 4.894303 5.097581 4.752782 4.628371 5.333848 5.036416 5.257309 4.609605\n [81] 5.184192 5.229711 5.316874 4.935175 4.630972 5.059328 5.080439 4.923191\n [89] 5.564449 4.840336 4.778244 4.910046 4.890228 5.803821 4.597359 5.034822\n [97] 5.004193 4.842067 5.046290 5.192478\n\n[[2]]\n  [1] 4.466570 4.619031 4.022234 4.828505 4.246242 4.124056 4.588208 5.056415\n  [9] 4.462401 4.442259 4.602219 4.712382 4.667207 4.667028 4.526850 4.390890\n [17] 4.310906 4.883069 4.271361 4.951216 4.589956 4.342607 4.330297 4.432282\n [25] 4.433938 4.811139 4.399874 4.423267 4.563278 4.640146 4.617160 4.117204\n [33] 4.585883 4.609707 4.733523 4.680524 4.623114 4.594910 4.666122 4.656637\n [41] 4.451875 4.420331 4.605745 4.649875 4.429742 4.609523 4.134343 5.113835\n [49] 4.424969 4.928719 4.327575 5.004125 4.246994 4.594632 4.691098 4.278484\n [57] 4.398825 4.207993 4.574355 4.226589 4.612187 4.598995 4.518066 4.618010\n [65] 4.509008 4.425050 4.831216 4.753106 4.285328 4.515222 4.576484 4.243922\n [73] 4.312133 4.326376 4.364893 4.205415 4.634487 4.517175 4.062072 5.084034\n [81] 4.835280 4.660257 4.401611 4.536356 4.603107 4.437586 4.663069 4.813495\n [89] 4.361790 4.823949 5.333890 4.583438 4.576911 4.384318 4.610598 4.511460\n [97] 4.486576 4.259209 4.164961 4.357421\n\n\nand the sampled estimates,\n\n# simulated estimates\nt_S <- purrr::map_dbl(sim$S, ~ surv_median(.x[[1]], \"S\"))\nt_low <- purrr::map_dbl(sim$S, ~ surv_median(.x[[1]], \"low\"))\nt_upp <- purrr::map_dbl(sim$S, ~ surv_median(.x[[1]], \"upp\"))\n\nPlotting the two sets of medians we can see the location and spread for both distributions together.\n\nplot(fit2) + \n  geom_vline(xintercept = rtimes[[1]], alpha = 0.1, col = \"pink\", size = 2) +\n  geom_vline(xintercept = rtimes[[2]], alpha = 0.1, col = \"lightblue\", size = 2) +\n  geom_vline(xintercept = t_S[[1]]) +\n  geom_vline(xintercept = t_low[[1]], linetype = 2) +\n  geom_vline(xintercept = t_upp[[1]], linetype = 2) +\n  geom_vline(xintercept = t_S[[2]]) +\n  geom_vline(xintercept = t_low[[2]], linetype = 3) +\n  geom_vline(xintercept = t_upp[[2]], linetype = 3)\n\n\n\n\n\n\nMultiple percentiles\nA general formula for the \\(p\\)th sample percentile of the survival time distribution is computed as\n\\[\nt_p = \\frac{1}{2} \\left( \\min\\{t:1−\\hat{S}(t) ≥ p\\} + \\max\\{t:1−\\hat{S}(t) ≤ p\\} \\right)\n\\]\nSo, analogous to the median only example above, let us fit an exponential distribution.\n\nmle <- fit.models(formula = Surv(recyrs, censrec) ~ 1,\n                  data = bc,\n                  distr = \"exp\",\n                  method = \"mle\")\n\nsurv <- make.surv(mle, nsim = NSIM)\n\nWe can extend the surv_median function by creating a function factory which we can use to create equivalent functions for different percentiles.\n\nsurv_percentile <- function(p) {\n  force(p)\n  function(S, sname)\n    min(S[[\"t\"]][S[[sname]] < p])\n}\n\nsurv_median <- surv_percentile(0.5)\nsurv_median(surv$S[[1]], \"S\")\n\n[1] Inf\n\n\nNow we can automatically create functions for all the percentiles of interest by mapping over the vector of probabilities, which returns a list of functions.\n\nprctile <- c(\"97.5\" = 0.975, \"75\" = 0.75, \"50\" = 0.5, \"25\" = 0.25, \"2.5\" = 0.025)\n\np_fns <- purrr::map(prctile, surv_percentile)\n\nhead(p_fns)\n\n$`97.5`\nfunction(S, sname)\n    min(S[[\"t\"]][S[[sname]] < p])\n<bytecode: 0x00000216baa60d38>\n<environment: 0x00000216bb4b3ab8>\n\n$`75`\nfunction(S, sname)\n    min(S[[\"t\"]][S[[sname]] < p])\n<bytecode: 0x00000216baa60d38>\n<environment: 0x00000216baa63560>\n\n$`50`\nfunction(S, sname)\n    min(S[[\"t\"]][S[[sname]] < p])\n<bytecode: 0x00000216baa60d38>\n<environment: 0x00000216baa63288>\n\n$`25`\nfunction(S, sname)\n    min(S[[\"t\"]][S[[sname]] < p])\n<bytecode: 0x00000216baa60d38>\n<environment: 0x00000216baa62fb0>\n\n$`2.5`\nfunction(S, sname)\n    min(S[[\"t\"]][S[[sname]] < p])\n<bytecode: 0x00000216baa60d38>\n<environment: 0x00000216baa62cd8>\n\n\nEquivalent to what we did with just the median function we can do the same with the list of percentile functions.\n\nsimdat <- surv$S[[1]]\n\n# example for median i.e. 50% percentile\np_fns$`50`(simdat, \"S\")\n\n[1] Inf\n\ne_times <- purrr::map_dbl(p_fns, ~ do.call(.x, list(simdat, \"S\")))\nupp_times <- purrr::map_dbl(p_fns, ~ do.call(.x, list(simdat, \"upp\")))\nlow_times <- purrr::map_dbl(p_fns, ~ do.call(.x, list(simdat, \"low\")))\n\nWe can plot all of the percentile times with error bounds as follows.\n\nplot(mle) + \n  geom_vline(xintercept = e_times) +\n  geom_vline(xintercept = upp_times, linetype = 2) +\n  geom_vline(xintercept = low_times, linetype = 2) +\n  annotate(\"text\", x = e_times + 0.5, y = 0.25, label = prctile)\n\n\n\n\n\n\nComparing between all distribution fits and Kaplan-Meier\nIn this section we bring together various things from previous sections. We will do an analysis for all 6 main distributions at the same time and for several percentiles.\nFirst, we fit all of the models and then generate the sample of survival curves.\n\ndist_names <- c(\"exponential\", \"weibull\", \"gompertz\", \"loglogistic\", \"lognormal\", \"gengamma\")\n\nmle <- fit.models(formula = Surv(recyrs, censrec) ~ 1,\n                  data = bc,\n                  distr = dist_names,\n                  method = \"mle\")\n\nsurv <- purrr::map(setNames(1:6, dist_names), ~ make.surv(mle, mod = .x, nsim = NSIM))\n\nNow, for each distribution we calculate the survival times at each chosen percentile.\n\ntimes <- list()\n\nfor (i in dist_names) {\n  simdat <- surv[[i]]$S[[1]]\n  times[[i]] <- purrr::map_dbl(p_fns, ~ do.call(.x, list(simdat, \"S\")))\n}\n\nFinally, we can plot the results, including the Kaplan-Meier estimates.\n\nlibrary(scales)\n\n## ggplot2 default colours\ncols <- hue_pal()(6)\nkm_dat <- mle$misc$km\n\nt_km <- purrr::map_dbl(prctile, ~min(km_dat$time[km_dat$surv < .x]))\n\nplot(mle) + \n  purrr::map(seq_along(times), ~ geom_vline(xintercept = times[[.x]], col = cols[.x])) +\n  geom_vline(xintercept = t_km, size = 1.5, linetype = 2)\n\n\n\n\nWe haven’t included the upper and lower bound here because the plot would be too busy but it is trivial to extend the code above to do this.\nLet us create a table of these percentile outputs too.\n\ntab <- t(do.call(rbind, times))\ntab <- cbind(tab, Observed = t_km)\n\nknitr::kable(round(tab, 2))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nexponential\nweibull\ngompertz\nloglogistic\nlognormal\ngengamma\nObserved\n\n\n\n\n97.5\nInf\nInf\nInf\nInf\nInf\nInf\n0.56\n\n\n75\nInf\nInf\nInf\nInf\nInf\nInf\n1.99\n\n\n50\nInf\nInf\nInf\nInf\nInf\nInf\n4.95\n\n\n25\nInf\nInf\nInf\nInf\nInf\nInf\nInf\n\n\n2.5\nInf\nInf\nInf\nInf\nInf\nInf\nInf\n\n\n\n\n\n\n\nSurvival probabilities at given times\nWe can flip the analysis around and instead obtain survival probabilities at user-defined time points.\nThe code looks veery similar to the percentile case above.\n\nt_pt <- c(1,2,5)\n\nS_est <- list()\n\nfor (i in dist_names) {\n  simdat <- surv[[i]]$S[[1]]\n  S_est[[i]] <- purrr::map_dbl(t_pt, ~min(simdat$S[simdat$t < .x]))\n}\n\n\nkm_dat <- mle$misc$km\nt_km <- purrr::map_dbl(t_pt, ~min(km_dat$surv[km_dat$time < .x]))\n\nplot(mle) + \n  purrr::map(seq_along(S_est), ~ geom_hline(yintercept = S_est[[.x]], col = cols[.x])) +\n  geom_vline(xintercept = t_pt) +\n  geom_hline(yintercept = t_km, size = 1.5, linetype = 2)\n\n\n\n\nLet us create a table of these survival probabilities as percentages.\n\ntab <- t(do.call(rbind, S_est))\ntab <- cbind(time = t_pt, tab*100, Observed = t_km*100)\n\nknitr::kable(round(tab, 0))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntime\nexponential\nweibull\ngompertz\nloglogistic\nlognormal\ngengamma\nObserved\n\n\n\n\n1\nInf\nInf\nInf\nInf\nInf\nInf\n92\n\n\n2\nInf\nInf\nInf\nInf\nInf\nInf\n75\n\n\n5\nInf\nInf\nInf\nInf\nInf\nInf\n49\n\n\n\n\n\n\n\ncalc_medians() function\n##TODO:\n## \ncalc_medians <- function(fit, NSIM = 10) {\n  \n  dist_names <- names(fit$models)\n  ndist <- length(dist_names)\n  \n  med_sim <- list()\n  med_direct <- list()\n  surv <- list()\n  \n  for (i in dist_names) {\n    surv[[i]] <- make.surv(fit, mod = which(i == dist_names), nsim = NSIM)\n    simdat <- surv[[i]]$S[[1]]\n    \n    med_sim[[i]] <- c(median = surv_median(simdat, \"S\"),\n                      upp = surv_median(simdat, \"upp\"),\n                      low = surv_median(simdat, \"low\"))\n    \n    params <- sample_params(fit$models[[i]])\n    \n    ##TODO: mean, upper and lower and/or all samples?\n    # median_fn <- fit$models[[i]]$dfns$q\n    # med_args <- c(p = 0.5, lower.tail = FALSE)\n    # med_direct[[i]] <- purrr::map(params, ~ do.call(median_fn, c(med_args, as.list(.x))))\n    med_direct[[i]] <- purrr::map_dbl(params, ~ do.call(median_fn(i), as.list(.x)))\n  }\n  \n  list(med_direct,\n       med_sim)\n}\n\nmedian_fn <- function(x) {\n  switch(x,\n         \"Exponential\"   = function(rate) -log(0.5)/rate,\n         \"log-Logistic\"  = function(shape, scale) scale,\n         \"Gompertz\"      = function(shape, rate) (1/rate)*log((-1/exp(shape))*log(0.5) + 1),\n         \"Weibull (AFT)\" = function(shape, scale) scale*(log(2)^(1/shape)),\n         \"log-Normal\"    = function(meanlog, sdlog) exp(meanlog),\n         \"Gen. Gamma\"    = function(...) NA)\n}\n\nsurv_median <- function(S, sname) {\n  min(S[[\"t\"]][S[[sname]] < 0.5])\n}\n\nsample_params <- function(fit, ...) {\n  UseMethod(\"sample_params\")\n}\n\nsample_params.flexsurvreg <- function(model, nsim = 10) {\n  sboot <- normboot.flexsurvreg(model, B = nsim)\n  asplit(sboot, 1)\n}\n\nsample_params.stan <- function() {\n  rstan::extract(model)\n}\n\ncalc_medians(mle)\n\n\nWarning in min(S[[\"t\"]][S[[sname]] < 0.5]): no non-missing arguments to min;\nreturning Inf\n\nWarning in min(S[[\"t\"]][S[[sname]] < 0.5]): no non-missing arguments to min;\nreturning Inf\n\nWarning in min(S[[\"t\"]][S[[sname]] < 0.5]): no non-missing arguments to min;\nreturning Inf\n\nWarning in min(S[[\"t\"]][S[[sname]] < 0.5]): no non-missing arguments to min;\nreturning Inf\n\nWarning in min(S[[\"t\"]][S[[sname]] < 0.5]): no non-missing arguments to min;\nreturning Inf\n\nWarning in min(S[[\"t\"]][S[[sname]] < 0.5]): no non-missing arguments to min;\nreturning Inf\n\nWarning in min(S[[\"t\"]][S[[sname]] < 0.5]): no non-missing arguments to min;\nreturning Inf\n\nWarning in min(S[[\"t\"]][S[[sname]] < 0.5]): no non-missing arguments to min;\nreturning Inf\n\nWarning in min(S[[\"t\"]][S[[sname]] < 0.5]): no non-missing arguments to min;\nreturning Inf\n\nWarning in min(S[[\"t\"]][S[[sname]] < 0.5]): no non-missing arguments to min;\nreturning Inf\n\nWarning in min(S[[\"t\"]][S[[sname]] < 0.5]): no non-missing arguments to min;\nreturning Inf\n\nWarning in min(S[[\"t\"]][S[[sname]] < 0.5]): no non-missing arguments to min;\nreturning Inf\n\nWarning in min(S[[\"t\"]][S[[sname]] < 0.5]): no non-missing arguments to min;\nreturning Inf\n\nWarning in min(S[[\"t\"]][S[[sname]] < 0.5]): no non-missing arguments to min;\nreturning Inf\n\nWarning in min(S[[\"t\"]][S[[sname]] < 0.5]): no non-missing arguments to min;\nreturning Inf\n\nWarning in min(S[[\"t\"]][S[[sname]] < 0.5]): no non-missing arguments to min;\nreturning Inf\n\nWarning in min(S[[\"t\"]][S[[sname]] < 0.5]): no non-missing arguments to min;\nreturning Inf\n\nWarning in min(S[[\"t\"]][S[[sname]] < 0.5]): no non-missing arguments to min;\nreturning Inf\n\n\n[[1]]\n[[1]]$Exponential\n [1] 4.966553 4.827020 4.883045 5.628640 5.035439 5.292257 5.089955 4.804941\n [9] 4.982657 4.810618\n\n[[1]]$`Weibull (AFT)`\n [1] 4.743420 4.493634 4.745278 4.337766 4.626728 4.657598 4.464190 4.717536\n [9] 4.582725 4.676070\n\n[[1]]$Gompertz\n [1] 4.046255 4.358841 4.227582 4.307995 4.373330 3.678017 3.759001 4.338441\n [9] 3.509706 3.523070\n\n[[1]]$`log-Logistic`\n [1] 5.013626 4.066543 4.580682 4.959065 4.212073 4.036718 4.555648 4.273214\n [9] 4.446469 4.491434\n\n[[1]]$`log-Normal`\n [1] 4.657814 4.132980 4.784933 5.107095 4.871923 4.441884 4.251263 4.747124\n [9] 4.518871 4.463943\n\n[[1]]$`Gen. Gamma`\n [1] NA NA NA NA NA NA NA NA NA NA\n\n\n[[2]]\n[[2]]$Exponential\nmedian    upp    low \n   Inf    Inf    Inf \n\n[[2]]$`Weibull (AFT)`\nmedian    upp    low \n   Inf    Inf    Inf \n\n[[2]]$Gompertz\nmedian    upp    low \n   Inf    Inf    Inf \n\n[[2]]$`log-Logistic`\nmedian    upp    low \n   Inf    Inf    Inf \n\n[[2]]$`log-Normal`\nmedian    upp    low \n   Inf    Inf    Inf \n\n[[2]]$`Gen. Gamma`\nmedian    upp    low \n   Inf    Inf    Inf"
  },
  {
    "objectID": "other-hybrid-methods.html",
    "href": "other-hybrid-methods.html",
    "title": "Other hybrid methods",
    "section": "",
    "text": "References\n\nGelber, Richard D., Aron Goldhirsch, and Bernard F. Cole. 1993. “Parametric extrapolation of survival estimates with applications to quality of life evaluation of treatments.” Control. Clin. Trials 14 (6): 485–99. https://doi.org/10.1016/0197-2456(93)90029-D."
  },
  {
    "objectID": "PH-modelling.html",
    "href": "PH-modelling.html",
    "title": "Proportional Hazard Modelling",
    "section": "",
    "text": "The purpose of the CPH model is to evaluate simultaneously the effect of several factors on survival. It allows us to examine how specified factors influence the rate of a particular event happening at a particular point in time. This rate is commonly referred as the hazard rate.\nThe Cox model is expressed by the hazard function denoted by \\(h(t)\\). The hazard function can be interpreted as the risk of dying at time \\(t\\).\nIt can be estimated as follow:\n\\[\nh(t) = h_0(t) \\times \\exp (\\beta_1 x_1 + \\beta_2 x_2 + \\cdots + \\beta_p x_p)\n\\]\nwhere\n\n\\(h_0\\) is the baseline hazard corresponding to the value of the hazard if all of the \\(x_i\\) are equal to zero.\nEach \\(\\exp(\\beta_i)\\) are the hazard ratios. Id HR < 1the there is a reduction in the hazard and if HR > 1 then there is an increase in the hazard.\n\n\n\nWe will use the standard package survival for this and the package survminer which has some nice plotting functions.\n\nlibrary(\"survival\")\nlibrary(\"survminer\")\n\nLoad the data\n\ndata(\"lung\")\n\nWarning in data(\"lung\"): data set 'lung' not found\n\nhead(lung)\n\n  inst time status age sex ph.ecog ph.karno pat.karno meal.cal wt.loss\n1    3  306      2  74   1       1       90       100     1175      NA\n2    3  455      2  68   1       0       90        90     1225      15\n3    3 1010      1  56   1       0       90        90       NA      15\n4    5  210      2  57   1       1       90        60     1150      11\n5    1  883      2  60   1       0      100        90       NA       0\n6   12 1022      1  74   1       1       50        80      513       0\n\n\nand compute a univariate Cox model\n\nres.cox <- coxph(Surv(time, status) ~ sex, data = lung)\nsummary(res.cox)\n\nCall:\ncoxph(formula = Surv(time, status) ~ sex, data = lung)\n\n  n= 228, number of events= 165 \n\n       coef exp(coef) se(coef)      z Pr(>|z|)   \nsex -0.5310    0.5880   0.1672 -3.176  0.00149 **\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n    exp(coef) exp(-coef) lower .95 upper .95\nsex     0.588      1.701    0.4237     0.816\n\nConcordance= 0.579  (se = 0.021 )\nLikelihood ratio test= 10.63  on 1 df,   p=0.001\nWald test            = 10.09  on 1 df,   p=0.001\nScore (logrank) test = 10.33  on 1 df,   p=0.001\n\n\nFor a multivariate Cox model it is a simple extension\n\nres.cox <- coxph(Surv(time, status) ~ age + sex + ph.ecog, data =  lung)\nsummary(res.cox)\n\nCall:\ncoxph(formula = Surv(time, status) ~ age + sex + ph.ecog, data = lung)\n\n  n= 227, number of events= 164 \n   (1 observation deleted due to missingness)\n\n             coef exp(coef)  se(coef)      z Pr(>|z|)    \nage      0.011067  1.011128  0.009267  1.194 0.232416    \nsex     -0.552612  0.575445  0.167739 -3.294 0.000986 ***\nph.ecog  0.463728  1.589991  0.113577  4.083 4.45e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n        exp(coef) exp(-coef) lower .95 upper .95\nage        1.0111     0.9890    0.9929    1.0297\nsex        0.5754     1.7378    0.4142    0.7994\nph.ecog    1.5900     0.6289    1.2727    1.9864\n\nConcordance= 0.637  (se = 0.025 )\nLikelihood ratio test= 30.5  on 3 df,   p=1e-06\nWald test            = 29.93  on 3 df,   p=1e-06\nScore (logrank) test = 30.5  on 3 df,   p=1e-06\n\n\nWe can visualise the output as follows.\n\nfit <- survfit(Surv(time, status) ~ sex, data = lung)\n\n# base R\nplot(fit)\n\n# ggplot2\nggsurvplot(fit, conf.int = TRUE,\n           ggtheme = theme_minimal(), data = lung)"
  },
  {
    "objectID": "restricted-means.html",
    "href": "restricted-means.html",
    "title": "Restricted Means",
    "section": "",
    "text": "Restricted mean survival time (RMST) analysis can be used either for the base case analysis or as a sensitivity analysis. The method as used in the NICE TAs generally involved simply using all the available data to estimate the area under the Kaplan Meier curve up until the final observation, similar to an approach presented in the statistical literature by (Moeschberger1985?). Generally, a restricted means approach has only been taken when trial data was relatively complete compared to situations where parametric modelling was used.\n\\[\n\\mu_{\\tau} = \\mbox{E}[T \\mid \\boldsymbol{\\theta}]= \\int_0^{\\tau} S(t)dt.\n\\]"
  },
  {
    "objectID": "restricted-means.html#calculation-in-r",
    "href": "restricted-means.html#calculation-in-r",
    "title": "Restricted Means",
    "section": "Calculation in R",
    "text": "Calculation in R\nflexsurv has some in-built functions to easily calculate RMST. The names of these functions are pre-pended with rmst_ e.g. rmst_exp().\nTo see this, let us calculate the RMST for an exponential distribution rate 1 and \\(t \\leq 0.5\\).\n\nlibrary(flexsurv)\n\nLoading required package: survival\n\nt <- 0.5\n\nrmst_exp(t, rate = 1, start = 0)\n\n[1] 0.3934693\n\nden <- curve(dexp, 0, 5)\n\npolygon(x = c(den$x[den$x <= t], t, 0),\n        y = c(den$y[den$x <= t], 0, 0),\n        col = \"slateblue1\",\n        border = 1)"
  },
  {
    "objectID": "restricted-means.html#as-an-alternative-to-hazard-ratio",
    "href": "restricted-means.html#as-an-alternative-to-hazard-ratio",
    "title": "Restricted Means",
    "section": "As an alternative to hazard ratio",
    "text": "As an alternative to hazard ratio\nThe survRM2 package is specifically for comparing restricted means analyses.\n\nlibrary(survRM2)\n\nD <- rmst2.sample.data()\n\ntime   <- D$time\nstatus <- D$status\narm    <- D$arm\n\nobj <- rmst2(time, status, arm, tau=10)\n\nplot(obj, xlab=\"Years\", ylab=\"Probability\")\n\n\n\n\n[Royston2013]\nRoyston, P., Parmar, M.K. Restricted mean survival time: an alternative to the hazard ratio for the design and analysis of randomized trials with a time-to-event outcome. BMC Med Res Methodol 13, 152 (2013). https://doi.org/10.1186/1471-2288-13-152"
  }
]